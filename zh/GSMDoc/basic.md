## 目录
*  [GSM文件结构概述](#gsm文件结构概述)
*  [代码块基本结构](#代码块基本结构)
*  [链接语句](#链接语句)
*  [输入输出](#输入输出)
*  [MTL文件结构](#MTL文件结构)
*  [其它基础知识](#其它基础知识)
*  [返回](./menu.md)

# GSM文件结构概述
所有的GSM文件都存储在set\material\lib目录下，其中的子文件夹对代码本身没有特别的意义，可以按照喜好创建任意名字的文件夹。  
Men of War II\modeling\resource\set\material\lib中存储了官方的GSM代码，作为代码参考。

标准的GSM文件如下所示

```
;这是一个注释
{"Material"
	{"codeBlockX"
		{uid a}
		{position xxx xxx}
	}
  	{"Material"
		{uid b}
		{position xxx xxx}
		{properties
			{lighting_model metallic_roughness}
		}
	}
  
  {l1 a b};链接语句
}
```
我不会在这里从头教MOW II的脚本语法，详见[Basic knowledge about configuration files | GEM RTS v1 | Documentation (gitbook.io)](https://bestway-1.gitbook.io/documentation/foundational-knowledge/basic-knowledge-about-configuration-files)  
所以让我们直接从GSM本身的结构开始：  
  
如果我们将一个大括号{}包括的内容称为一个**代码块**（我稍后解释为什么这么叫），那么
>一个GSM文件总是由一个名称为"Material"的代码块组成，我们叫它主代码块；
>
>一个GSM文件一定在主代码块中包含一个名字同样为"Material"的子代码块，其为整个GSM的**输出块**。所有可能的输出均汇总到该代码块上；
>
>一个GSM文件，在大部分情况下包含超过一个相互独立的子代码块，每个代码块一定具有>=1个输出参数和>=0个输入参数，在接下来，我们会称这些参数为**引脚**；
>>如果有超过一个子代码块，则他们之间使用**链接语句**将当前代码块的输出与下一个代码块的输入相连。

# 代码块基本结构
为什么要叫代码块？因为实际上GSM文件在运行时会被转换成HLSL代码，然后加入其余的着色器代码中被一同编译。一个代码块本质上代表了1行或多行HLSL语句。该过程的细节详见[附录1 GSM代码编译流程](./other.md#附录1-gsm代码编译流程)。  
此外，在材质编辑器中每个代码块真的以方块的形式显示。

一个代码块的结构如下所示
```
    {"codeBlock"
        {uid a}
        {position xxx xxx}
        {properties
            {comments "tihs is a comment"}
            {m n}
        }
    }
```
它包含几个主要部分：
* "codeBlock" 代码块的类型
* uid 该代码块的唯一标识符，在单个GSM文件中uid**不能重复**，在链接语句中我们用它来索引对应的代码块
* position  该代码块在材质编辑器的2d可视化窗口中的位置
* properties 该代码块的参数，每个参数以{m n}的形式表示，m是参数名，n是参数。
    * 该部分不是必须的。
    * 其中comments是一个特殊的参数，它会被视作注释，与直接使用 ; 符号注释相似。我猜测这样注释可以在材质编辑器中显示
    * 可能可以透过properties直接定义输入参数的值，见[Pan块的实例](./codeBlock.md#pan)

此外，除了[少数情况](./custom.md)代码块的输入输出并不直接显示。  
具体可用的代码块类型在[可用的代码块类型](./codeBlock.md)中展示。

# 链接语句

GSM支持两种类型的代码块间引脚链接
```
    {l1 a b}
    {l2 a x b y}
```
l1=简单引脚链接  
{l1 a b}=将a块的第0个输出作为b块的第0个输入  
l2=特定引脚链接  
{l2 a x b y}=将a块的第x个输出作为b块的第y个输入  
引脚的计数从0开始  

你也许会在实际的官方代码里看到
```
    {l1 a b m n o}
    {l2 a x b y m n o}
```
这样的链接代码，但是很可惜我还不知道额外的参数m n o等有什么意义。  
一个很可能的猜测是这些参数被用于材质编辑器：定义某种固定可视化链接线条的锚点或者别的什么东西。  
不论如何，就我观测到的情况而言，无视这些参数目前是无害的。

# 输入输出
目前，你可以**假设**GSM的输入全部由代码块引入，所以我们会在GSM中实现一个从代码块输入参数，进行各种计算并最终汇总到输出块的函数。  
请注意，这个假设是**错误**的，我们会在[内置辅助函数及变量](./helper.md)和[自定义代码块](./custom.md)两个章节中提到不符合这个假设的内容。  
但是在目前，这样思考并编写代码没有问题。

输入是多种多样的，我们会在[可用的代码块类型](./codeBlock.md)中阐述。而在这里我们只关注GSM的输出，即输出块的相关知识。  
输出块通过在properties中定义lighting_model（即光照模型）字符串，使GSM支持以下四种不同类型的输出：
* 无参数
* phong
* phong_gem2
* metallic_roughness
* marschner

* 请注意，  
    * 无参数一样是可以正常输出的，这五种光照模型类型定义了不同的输出引脚
    * marschner很可能是一个未完成的用于各向异性头发着色器的光照模型，其的字面意思指向论文[《Light Scattering from Human Hair Fibers》](https://www.graphics.stanford.edu/papers/hair/hair-sg03final.pdf)，在这里我不做过多介绍
    * phong和phong_gem2是基于经验公式的传统光照模型，gem2可能拥有一些更先进的功能，但是我没有深究这其中的区别。类似的，我也没有记录这些光照模型的引脚类型，这部分内容会在之后补充
    * metallic_roughness是基于金属度-粗糙度的PBR光照模型，我们简称为PBR或者PBR模型，这是接下来要关注的重点内容

参考该图  
<img src=../../img/mted.png width=50% />  
PBR模型的引脚对照表如下  
| diffuse | emissive| opacity | normal | transform | translucence | roughness | metallic | shadow | fresnel |
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 0     | 1     | 2     | 5     | 6     | 8     | 9     | 20     | 21     | 22     |

中文版本：
| 漫反射 | 自发光| 透明度 | 法线 | 变换 | 透光度 | 粗糙度 | 金属度 | 阴影 | 菲涅耳 |
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 0     | 1     | 2     | 5     | 6     | 8     | 9     | 20     | 21     | 22     |

该表的意思是：如果设置链接语句{l2 a 0 输出块 2}，则会把a的第0个引脚输出到透明度（opacity）  
接下来介绍每个引脚的具体含义：

### diffuse
数据类型：float3  
漫反射引脚，一般输出数据为包含RGB三通道颜色的信息。  
其用于显示物体最基本的固有颜色。  
### emissive
数据类型：float3  
自发光引脚，大致可以理解成输出一个叠加到漫反射上的不受环境光照影响的漫反射贴图，因为MOW II的自发光贴图并不参与全局光照计算。  
### opacity
数据类型：float  
透明度引脚，需要注意的是它只负责输出透明度，透明的具体计算方式仍然由mtl中的{blend X}参数控制。
### normal
数据类型：float3  
法线引脚，输出世界空间（很可能是，不确定）的法线信息。
### transform
顶点变换引脚，输出对顶点信息的改动。  
该引脚非常特殊，无法简单描述它的数据类型，我们将在[自定义代码块](./custom.md)中提到它的具体使用。平常情况下不需要连接该引脚，着色器的其他部分会完成该引脚涉及到的一般流程。  
### translucence
数据类型：float3  
透光度引脚  
我对该引脚的理解不深入，大致效果可以参考[半透明明暗器](https://help.autodesk.com/view/3DSMAX/2022/CHS/?guid=GUID-67CD32E8-A0D5-4A14-8179-FB11D3E3DD28)  
请注意，它很可能与次表面散射无关。  
一般情况下也不需要连接该引脚。  
### roughness
数据类型：float  
粗糙度引脚，该值越高物体的表面越粗糙，反之则越光滑。  
我们偶尔会提到另一个词汇smoothness（光滑度），其是粗糙度的反相。  
### metallic
数据类型：float  
金属度引脚，该值越高物体的表面越像金属，反之不像光滑。
### shadow
数据类型：float  
实际上应该被称为Ambient Occlusion（环境光遮蔽），也并不能完全改变阴影。  
其的值越大，则阴影越重。
### fresnel
数据类型：float  
其代表PBR中的f0值，f0的意义可以参考[材质制作参数F0](https://liangz0707.github.io/whoimi/blogs/Art/%E6%9D%90%E8%B4%A8%E5%88%B6%E4%BD%9C%E5%8F%82%E6%95%B0F0.html)，其与物体的折射率有关。  
如果你不知道这是什么，不要连接该引脚，着色器会调用一个默认值。

# MTL文件结构
```
{"npr/simple" 
	;贴图参数
	;如果你不需要对应的贴图，使用占位符替代
	;在 $/pbr 有三个占位符 0_ao=环境光遮蔽 0_nm=法线 0_met=金属度
	{diffuse "turret_Base_Color"}
	


	;可选参数
    {diffuseColor 0xffffff}
	{opacity 1}
	{blend none};none=不透明 blend=半透明 test=剔除 add=?
}
```
与旧GEM引擎的MTL相比变化不大，主要参数类型为：
* {xxx "tex"} 贴图参数[[必须注意的bug]](#已知问题)
* {xxx 0xffffff} 16进制颜色参数
* {xxx 1} 浮点参数
* {blend none} 透明计算方法
* 待补充
# 其它基础知识

### GSM实际操控的着色器类型
我们可以透过GSM控制顶点着色器，和像素着色器的早期阶段。  
大致上这是一个猜测，因为我无法访问实际的着色器代码，但是这样想是有依据的：
* 因为transform引脚的存在，我们可以完全控制顶点着色器，没有任何问题
* 我们似乎无法访问实际的光照计算阶段，没法获得光源信息，没法控制阴影，光的反射折射或者任何实际的像素处理阶段
    * 实际上我们只是计算好了必要的信息，然后把它们投进一个黑箱里面

### GSM的缺点
具体地说，我会告诉你GSM无法做到什么：
* 无法定义新的输出引脚，我们无法向黑箱里传入新的信息
* 显然，也完全无法访问后处理阶段
* 无法访问曲面细分着色器，理论上它出现在shader_combinations.set中，意味着我们可能可以访问。但是我没有在任何地方找到可用的代码。这些信息很可能被硬编码在可执行文件中了
* 没有多PASS计算（也可能是我没看明白），意味着一些实际上广泛使用的图形学方法无法执行
* 引擎的其他部分无法访问着色器参数，你不能通过trigger或者MOW样式SDL或者任何别的东西访问着色器参数，除了在编辑器里手动调整或者写入MTL文件
* 参数没有范围控制：不错，我们可以透过数学来规范数字，但是在前端这一切都是被隐藏的。同时可用的参数类型只有float及其变种，尽管实际上你可以在一个代码块内部使用其它数据类型
* 缺乏明确的故障提示，绝大部分故障提示会在编译阶段产生，此时代码已经被编译成完全不同的HLSL代码，名字或者uid这样的标识符都被抹去了，这导致问题难以追踪

### 已知问题
* 采用写入MTL模式控制着色器时，会导致不一致行为：必须预定义全部贴图参数，否则调用着色器时引擎会反馈一个意义不明的故障